# FILE: backend/app/api/endpoints/drafting_v2.py
# PHOENIX PROTOCOL - DRAFTING ENDPOINT V2.5 (ACCOUNTING TRANSFORMATION)
# 1. REFACTOR: Function names and docstrings updated to "Business/Accounting" domain.
# 2. INTEGRITY: Preserved anti-buffering headers for real-time streaming performance.
# 3. STATUS: 100% Accounting Aligned.

from fastapi import APIRouter, Depends, status, HTTPException
from fastapi.responses import StreamingResponse
from typing import Annotated
from pymongo.database import Database
import logging

from ...models.user import UserInDB
from ...models.drafting import DraftRequest
from .dependencies import get_current_active_user, get_db
from ...services import drafting_service

router = APIRouter(tags=["Drafting V2"])
logger = logging.getLogger(__name__)

@router.post("/stream")
async def stream_business_draft(
    request_data: DraftRequest,
    current_user: Annotated[UserInDB, Depends(get_current_active_user)],
    db: Database = Depends(get_db)
):
    """
    PHOENIX: Direct Streaming Endpoint for Business & Financial Documents. 
    Uses typewriter-effect streaming to bypass proxy buffering.
    """
    draft_type = request_data.document_type or "generic"
    
    # Anti-buffering headers to ensure immediate chunk delivery through Caddy/Nginx
    headers = {
        "X-Accel-Buffering": "no",
        "Cache-Control": "no-cache",
        "Connection": "keep-alive",
        "Content-Type": "text/plain; charset=utf-8"
    }

    return StreamingResponse(
        drafting_service.stream_draft_generator(
            db=db,
            user_id=str(current_user.id),
            case_id=request_data.case_id, # Maps to Client/Business ID
            draft_type=draft_type,
            user_prompt=request_data.prompt
        ),
        media_type="text/plain",
        headers=headers
    )

@router.post("/jobs", status_code=status.HTTP_202_ACCEPTED)
async def create_drafting_job(
    request_data: DraftRequest,
    current_user: Annotated[UserInDB, Depends(get_current_active_user)],
):
    """Initiates a background task for complex financial report generation."""
    from ...celery_app import celery_app
    try:
        task = celery_app.send_task(
            "process_drafting_job",
            kwargs={
                "case_id": request_data.case_id,
                "user_id": str(current_user.id),
                "draft_type": request_data.document_type,
                "user_prompt": request_data.prompt,
                "use_library": request_data.use_library
            }
        )
        return {"status": "Procesimi filloi me sukses", "job_id": task.id}
    except Exception as e:
        logger.error(f"Celery dispatch failed: {e}")
        raise HTTPException(status_code=500, detail="DÃ«shtoi nisja e procesit.")

@router.get("/jobs/{job_id}/status")
async def get_job_status(
    job_id: str, 
    current_user: Annotated[UserInDB, Depends(get_current_active_user)]
):
    from ...celery_app import celery_app
    from celery.result import AsyncResult
    task_result = AsyncResult(job_id, app=celery_app)
    return {"job_id": job_id, "status": task_result.status}

@router.get("/jobs/{job_id}/result")
async def get_job_result(
    job_id: str, 
    current_user: Annotated[UserInDB, Depends(get_current_active_user)], 
    db: Database = Depends(get_db)
):
    """
    Fetches the final business document generated by the AI agent.
    """
    result_doc = db.drafting_results.find_one({"job_id": job_id})
    if not result_doc: 
        raise HTTPException(status_code=404, detail="Dokumenti nuk u gjet.")
    return {"job_id": job_id, "result_text": result_doc.get("result_text")}