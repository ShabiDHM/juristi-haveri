# FILE: backend/app/api/endpoints/drafting_v2.py
# PHOENIX PROTOCOL - DRAFTING ENDPOINT V2.4 (STREAMING INTEGRITY FIX)
# 1. FIX: Added 'X-Accel-Buffering' and 'Cache-Control' headers to force Caddy/Nginx to flush chunks immediately.
# 2. FIX: Explicitly set charset to utf-8 in Content-Type to prevent encoding buffering.
# 3. STATUS: Real-time Typewriter Effect restored.

from fastapi import APIRouter, Depends, status, HTTPException
from fastapi.responses import StreamingResponse
from typing import Annotated
from pymongo.database import Database
import logging

from ...models.user import UserInDB
from ...models.drafting import DraftRequest
from .dependencies import get_current_active_user, get_db
from ...services import drafting_service

router = APIRouter(tags=["Drafting V2"])
logger = logging.getLogger(__name__)

@router.post("/stream")
async def stream_legal_draft(
    request_data: DraftRequest,
    current_user: Annotated[UserInDB, Depends(get_current_active_user)],
    db: Database = Depends(get_db)
):
    """
    PHOENIX: Direct Streaming Endpoint. 
    Uses Hydra Tactic to bypass Celery for instant UI feedback.
    Includes anti-buffering headers for Reverse Proxies.
    """
    # PHOENIX FIX: Ensure draft_type is a string (handles Optional[str] from model)
    draft_type = request_data.document_type or "generic"
    
    # PHOENIX FIX: Anti-buffering headers for Caddy/Nginx
    headers = {
        "X-Accel-Buffering": "no",
        "Cache-Control": "no-cache",
        "Connection": "keep-alive",
        "Content-Type": "text/plain; charset=utf-8"
    }

    return StreamingResponse(
        drafting_service.stream_draft_generator(
            db=db,
            user_id=str(current_user.id),
            case_id=request_data.case_id,
            draft_type=draft_type,
            user_prompt=request_data.prompt
        ),
        media_type="text/plain",
        headers=headers
    )

@router.post("/jobs", status_code=status.HTTP_202_ACCEPTED)
async def create_drafting_job(
    request_data: DraftRequest,
    current_user: Annotated[UserInDB, Depends(get_current_active_user)],
):
    from ...celery_app import celery_app
    try:
        task = celery_app.send_task(
            "process_drafting_job",
            kwargs={
                "case_id": request_data.case_id,
                "user_id": str(current_user.id),
                "draft_type": request_data.document_type,
                "user_prompt": request_data.prompt,
                "use_library": request_data.use_library
            }
        )
        return {"status": "Job initiated successfully", "job_id": task.id}
    except Exception as e:
        logger.error(f"Celery dispatch failed: {e}")
        raise HTTPException(status_code=500, detail="Failed to initiate job.")

@router.get("/jobs/{job_id}/status")
async def get_job_status(
    job_id: str, 
    current_user: Annotated[UserInDB, Depends(get_current_active_user)]
):
    from ...celery_app import celery_app
    from celery.result import AsyncResult
    task_result = AsyncResult(job_id, app=celery_app)
    return {"job_id": job_id, "status": task_result.status}

@router.get("/jobs/{job_id}/result")
async def get_job_result(
    job_id: str, 
    current_user: Annotated[UserInDB, Depends(get_current_active_user)], 
    db: Database = Depends(get_db)
):
    """
    Fetches the final result generated by the Agent from MongoDB.
    """
    result_doc = db.drafting_results.find_one({"job_id": job_id})
    if not result_doc: 
        raise HTTPException(status_code=404, detail="No result found.")
    return {"job_id": job_id, "result_text": result_doc.get("result_text")}